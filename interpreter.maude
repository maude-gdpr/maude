

load datatypes

view Aid from TRIV to DATA is
   sort Elt to Aid .
endv

view GData from TRIV to DATA is
   sort Elt to GData .
endv

view Expr from TRIV to DATA is
   sort Elt to Expr .
endv

view Contract from TRIV to DATA is
   sort Elt to Contract .
endv

view Pair from TRIV to DATA is
   sort Elt to Pair .
endv



*** Bound variables ***
fmod SUBST is
*** protecting META-LEVEL .
***protecting DATATYPES .
protecting MAP{Aid, GData} * (sort Map{Aid, GData} to Subst,
                             op empty : -> Map{Aid, GData} to noSub ) .


***op noSub : -> Subst .
*** eq noSub = (empty).Subst .

op dom : Aid Subst -> Bool .
op remove : Aid Subst -> Subst .

*** Non-comm composition operator for substitutions
op _#_ : Subst Subst -> Subst .
vars A A' : Aid . var D : GData . vars S1 S2  : Subst .

eq S1 # noSub = S1 .
eq S1 # ((A |-> D), S2) = insert(A,D,S1) # S2 .

eq dom(A, noSub) = false .
eq dom(A, ((A' |-> D), S1)) = if A == A' then true else dom(A, S1) fi .
eq dom(A, S1 # S2) = dom(A, S1) or dom(A, S2) .

eq remove(A, (S1, A |-> D)) =  S1 .
eq remove(A, S1) =  S1 [owise] .



***  eq element(E, emp) = false .
***  eq element(E, E' # L) = if E == E' then true else element(E, L) fi .

*** red insert('var1, str("test"), noSub) .
*** red insert('var2, int(4), insert('var1, str("test"), noSub)) .
*** red insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1] .
*** red upTerm(insert('var1, str("test"), noSub)) .
*** red downTerm(upTerm(insert('var1, str("test"), noSub)),noSub) .
*** red downTerm(upTerm(insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1]), null) .
*** red dom('var1, insert('var2, int(4), insert('var1, str("test"), noSub))) .
endfm




fmod EVAL is
protecting SUBST .
protecting LIST {Expr} * (sort LIST{Expr} to list) .
pr BOOL-OPS .

*** Evaluation of expressions
op eval	    : Expr Subst     -> GData .     *** evaluate expression
op eval	    : EmpList Subst     -> GData .     *** evaluate expression
op evalB    : Expr Subst     -> Bool .
op evalN    : Expr Subst     -> Nat .
op evalS    : Expr Subst     -> String .
op evalList : ExprList Subst -> DataList . *** maps list to values
op _+_      : GData GData -> GData .

*** Variables
var E E' : Expr .     var EL : ExprList .     var D D' : GData . var NsD NsD' : Data . var SD SD' : SenData .
var A : Aid .         var S : Subst .         var Q : Qid .
var I : Int .         var B : Bool .          var STR : String . var PL : PolicyId .

eq eval(A, S) = S [A] .
eq eval(D, S) = D .                                *** data
eq < NsD, PL > + NsD' = < (NsD app NsD'), PL > .
eq  NsD' + < NsD, PL > = < NsD' app NsD, PL > .
eq  NsD + NsD' = NsD app NsD' .
eq < NsD, PL > + < NsD', PL > = < NsD app NsD', PL > .


eq evalN(E,S) = eval(E,S) asNat .                  *** expressions
eq evalB(E,S) = eval(E,S) asBool .                 *** expressions
eq evalS(E,S) = eval(E,S) asStr .                  *** expressions
eq eval (emp, S)= emp .


*** standard evaluation of expression
***eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) . 
***eq eval(EL , S)  = evalList(EL, S) .       
***eq eval(setl(EL), S)  = setl(evalList(EL, S)) .   
***eq eval(Q [[EL]], S)  = Q [[ evalList(EL, S) ]] .   

*** lists  
eq evalList(emp, S)   = eval(emp, S) .
 eq evalList(E,,EL, S) = eval(E, S),, evalList(EL, S) .
            
*** eq evalList(E, S)   = eval(E, S) . *** not needed

endfm




fmod STATEMENTS is
pr DATA .

sorts Mid Cid Stm .             *** Mid = method identifiers
subsort Qid < Mid Cid .         *** Cid = class identifiers

op _._ (_)  : Expr Mid ExprList -> Stm [ctor] . *** remote call
op _@_   : Qid  Cid -> Mid [ctor] .
*** CREOL program syntax
op skip : -> Stm [ctor] .
op _::=_  : AidList Stm -> Stm [ctor] .  
op _::=_  : AidList ExprList -> Stm [ctor] .       *** simple assignment
op _::=_  : AidList Nat -> Stm [ctor] .       *** simple assignment
op _::= new_(_) : Aid Cid ExprList -> Stm [ctor] . *** object creation
op _(_) : Mid ExprList  -> Stm [ctor] .  *** sync. call
op cont   : Nat              -> Stm [ctor] .       *** sync. scheduling
op return : ExprList         -> Stm [ctor] .       *** method return
op delete :  Aid         -> Stm [ctor] .       *** method return
op free   : AidList          -> Stm [ctor] .       *** deallocation for labels
op freeze   : Stm              -> Stm [ctor] .       *** sync. scheduling
op _::=_? :  AidList Qid      -> Stm [ctor] . *** M?
op policy : Bool Nat -> ExprList [ctor] .
op cat(_) : MsgId -> Stm [ctor] .
op collect : Data Aid Aid -> ExprList [ctor] .
op logIn :  Data -> ExprList [ctor] .
op logOut : ->  Stm  .
op optIn   :  Aid Aid -> Stm [ctor] .
op optOut   : Bool Aid Aid -> Stm [ctor] .
op _._._ : Expr Mid ExprList -> Stm [ctor] .
op return-check(_) : ExprList -> Stm [ctor] .
op _::= contract(_,_) : Aid Data Aid -> Stm [ctor] .
op store(_,_) : Key Aid -> Stm [ctor] .
op store(_,_) : Key GData -> Stm [ctor] .


op _++_ : Expr Expr -> ExprList .



endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
pr STATEMENTS .
pr SUBST .
protecting LIST{Stm} * (sort List{Stm} to StmList,
                        sort NeList{Stm} to NeStmList,
                        op __ : List{Stm} List{Stm} -> List{Stm} to _;_ 
) .
protecting SET{Pair} * (sort NeSet{Pair} to NeScope,
                            sort Set{Pair} to Scope) .
			    
op if-consent(_,_){_}else{_} : Aid Aid StmList StmList -> Stm [ctor] .
op if-comply(_,_){_}else{_} : Aid ExprList StmList StmList -> Stm [ctor] .
op retrieve(_,_){_}else{_} : Aid Aid StmList StmList -> Stm [ctor] .

var SL : StmList .  *** note: SL matches also empty
var NeSL : NeStmList .
var EL : ExprList .
var B : Expr .
var V : Scope .
var St : Stm .
 

eq (emp ::= EL)     = skip . *** Note that skip takes a step

sorts Process NeMProc MProc RunStat  .
subsort Process < NeMProc < MProc .    *** Multiset of Processes
***subsort Scope < SetPair .
op noProc : -> MProc [ctor] .
op _+_ : Process Stm -> Process .

***op _++_ : NeMProc MProc -> NeMProc [ctor assoc comm id: noProc] .
***op _++_ : MProc NeMProc -> NeMProc [ctor assoc comm id: noProc] .
***op _++_ : MProc MProc   -> MProc   [ctor assoc comm id: noProc] .

*** A Process is a pair of Prog and bound variables ***
op _@_ : StmList Scope -> RunStat .
op idle : -> Process [format (!b o)] .
op error : -> Process [format (!b o)] . 
op _,_ : Subst RunStat -> Process [ctor format (o r nb o)] . 
var L : Subst .
eq (L, (nil @ V)) = idle . *** if 'label is needed this is dangerous!
eq ((L, SL @ V) + St) = (L, (SL ; St) @ V) .
**** eq idle = (noSub, nil).  *** may use in right hand sides, but not left.

endfm

***fmod TRACE is
***pr STM-LIST .
***sorts Trace NeTrace .
***subsort StmList < NeTrace < Trace  .
***op noTrace : -> Trace [ctor] .
***op _::_ : NeTrace Trace -> NeTrace [ctor assoc comm id: noTrace] .
***op _::_ : Trace NeTrace -> NeTrace [ctor assoc comm id: noTrace] .
***op _::_ : Trace Trace   -> Trace   [ctor assoc comm id: noTrace] .
***op genTrace(_,_) : StmList StmList -> Trace .

***var T T' : Trace . var NT NT' : NeTrace . var SL SL' : StmList . var D : GData . var A A' : Aid . var S : Stm .
***eq genTrace(SL, ((optIn(A, A')) ; SL')) = genTrace((SL ; (optIn(true, A, A'))), SL') ::  genTrace((SL ; (optIn(false, A, A'))), SL') .
***eq genTrace(SL, (S ; SL')) = genTrace((SL ; S), SL') .
***eq genTrace(SL, nil) = SL .


***endfm

*** CREOL classes ***
fmod CLASS is
protecting STM-LIST .

sorts    Class  Mtd MMtd Inh InhList . *** inheritance list
subsorts Inh < Expr .  
subsorts Inh < InhList .

op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
op noInh : -> InhList [ctor] .
op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .
op str(_) : Cid -> Data .

var Ih : Inh . 
var IL : InhList .
var S : Subst . 
var SL : StmList . 
vars Q Q' : Qid . 
var MM : MMtd .
var DL : DataList .
var O : Oid .
var N : Nat .
var AL : AidList .
var V : Scope .

eq  Ih ## IL ## Ih = Ih ## IL .

op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

subsort Mtd < MMtd .    *** Multiset of methods

op noMtd : -> Mtd [ctor] .
op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .



op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
   [format (b! b o o o b o o  b o o  b o o  b on o  b o  b! on )] .

op emptyClass : -> Class .
eq emptyClass = < 'noClass : Cl | Inh: noInh, Par: emp, Att: noSub, Mtds: noMtd, Ocnt: 0 > .

*** Class/method functions ***
op get : Qid MMtd Oid Nat DataList Scope -> Process .  *** fetches pair (code, vars)
op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                              *** method in the method multiset

eq Q in noMtd = false .
eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
     if (Q == Q') then true else (Q in MM) fi .

*** bind call to process
eq get(Q, noMtd, O, N, DL, V) = noProc . 
eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, N, DL, V) = 
    if Q == Q' 
    then (insert('caller, O, S), ((AL ::= DL) ; SL) @ V)
    else get(Q, MM, O, N, DL, V) fi .

endfm

***  objects ***
fmod OBJECT is
protecting CLASS .

sort Object .

op <_:_ | Att:_, Pr:_, Lcnt:_, Db:_> : 
       Oid Cid Subst Process Nat Subst -> Object 
         [ctor format (nr! r o o o  r o r  r o r  r o r o r r! no)] .


op noObj : -> Object [ctor] .

*** red < 'object1 : 'class | Att: noSub, Pr: idle, Lcnt: 0 > .
*** red downTerm(upTerm(< 'object1 : 'class | Att: noSub, Pr: idle, Lcnt: 0 >), noObj) .

endfm

fmod POLICY is protecting DATA .
protecting SET{Contract} * (sort NeSet{Contract} to NeSetCn,
                            sort Set{Contract} to SetCn) .
sort Policy .

op <_, _, _, _, _> : PolicyId Data Bool SetCn Nat -> Policy [ctor  format (nr! rr   o o  o o o o o o r! no) ] .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
protecting OBJECT .
protecting CONVERSION .
pr POLICY .

sort NatS . *** list of nats
subsort Nat < NatS .

sort Body Msg  MMsg Kid Queue History .
subsort Body < MMsg .
subsort Body < History .

op noMsg : -> Body [ctor] .
op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] .
op noHis  : -> History .
op _++_   : History History -> History .

*** INVOCATION and REPLY
op invoc(_,_,_,_,_) : Oid Nat Mid DataList Scope -> Body    *** invocation
      [ctor format (!r o o o o o o o o o o o o)] .  
op comp(_,_,_) : Oid DataList Scope -> Msg                 *** completion
      [ctor format (!r o o o o o o o o)] .

op n(_,_) : MsgId Process -> Msg                 *** completion
      [ctor format (!r o o o o o o)] .

op optInMsg(_,_,_) : Bool Aid Aid -> Body  [ctor format (!r o o o o o  o o o)] .
op optInMsg(_,_) :  Aid Aid -> Body  [ctor format (!r o o o  o o o)] .

op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
op error(_)   : String -> Msg [ctor format (nnr r o! or onn)] .     *** error 
op warning(_) : String -> Msg [ctor format (nnr! r! r! or onn)] .   *** warning 
*** Method binding messages
op bindMtd : Oid Oid Nat Qid DataList InhList Scope -> Msg [ctor] . 
*** Bind method request
*** Given: caller callee method params (list of classes to look in)
op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
*** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S). Try to find Q in
*** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


var  C   : Cid . var A : Aid .	 var  Q    : Qid . var  N    : Nat . var S : String . var O : Oid .
 op newId : Cid Nat -> Oid .
eq newId(Q, N)  = ob(qid(string(Q) + string(N,10))) .
 op policyId : Nat -> PolicyId .
 eq policyId(N) = policy(N) .
op newN : Nat Oid -> MsgId .
 eq newN(N, O) = n(N, O ) .
op key : Qid String -> Key .
eq key(Q, S) = k(Q,  S) .

op <_ | Log:_> : 
       Oid History -> Object 
         [ctor format (nr! r o o   r   r! no)] .
endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
protecting OBJECT .
protecting COMMUNICATION .
protecting POLICY .

sort NConfiguration Configuration  .

subsorts Object Msg  Class Policy  < NConfiguration .
***subsort NConfiguration < Configuration .
op { _ } : NConfiguration -> Configuration .

op noConf : -> Configuration [ctor ] .
op __ : NConfiguration NConfiguration -> NConfiguration [ctor assoc comm  ] .
op main {_,_}_ : Subst StmList NConfiguration -> Configuration .

var C : Cid . var E : ExprList .  var SL : StmList . var L : Subst . var MC : NConfiguration .
eq main { L, SL } MC = { < ob('main) : 'class | Att: ('this |-> ob('main) , 'purpose |-> str('main)),
                 Pr: (L, (SL @ empty)), Lcnt: 0, Db: noSub >  MC } .
endfm


*** THE MACHINE ***
mod INTERPRETER is
pr CONFIG .
pr EVAL .
protecting CONVERSION .

vars O O' : Oid .      vars C C' : Cid .
vars A A' A'' : Aid .      var AL : AidList .
vars E E' : Expr .     vars EL  : ExprList .        var D D' : GData . var DL : DataList .
var ST : Stm .         vars SL SL' SL'' : StmList . vars SL1 SL2 : NeStmList .
var P : Process .
vars S S' L L' DB : Subst .
vars N F : Nat .
vars I I' : InhList .
var MS : MMtd .
var NS : NatS .
var MM : MMsg .
var M : Mid .
var Q : Qid .
var MsgBody : Body .
var B B' : Bool .
var T : Nat .
var PL PL' : PolicyId .
var CnSet : SetCn .
vars Cn Cn' : Contract .
var Cfg : Configuration .
var NsD NsD' : Data .
var SD  : SenData .
var Ncfg Ncfg' : NConfiguration .
var STRING : String .
var K : Key . var MSG : Msg . var CLASS : Class . var POLICY : Policy . var H : History .
var V V' : Scope .



***op comply(_,_,_) : DataList Contract NConfiguration -> Bool .
***op checkcomply(_,_,_) : Data Contract NConfiguration -> Bool .
op comply(_,_) : Scope NConfiguration -> Bool .
op checkcomply(_,_) : Pair NConfiguration -> Bool .
op deleteF(_,_) : PolicyId NConfiguration -> NConfiguration [ctor] .
op tick : -> Msg .
op match : Expr Expr  -> Bool .
op deleteDATA : PolicyId Subst -> Subst .
op dec(_)     : NConfiguration -> NConfiguration .
op policyIn(_,_)   : DataList Contract -> Scope .
op cScope(_)  : Scope -> Stm .

eq comply((< PL ,, Cn > , V), Ncfg) = ((checkcomply((< PL ,, Cn >), Ncfg)) and (comply(V, Ncfg))) .
eq checkcomply((< PL ,, Cn >), (< PL, D', B, CnSet, T >) Ncfg) =  ((Cn in CnSet) and ( T =/= 0)) .
eq comply(empty , Ncfg) = true .
eq checkcomply((< PL ,, Cn >), Ncfg) =  false [owise] . 


eq policyIn((NsD ,, DL), Cn) =  policyIn (DL, Cn) .
eq policyIn((< NsD, PL > ,, DL), Cn) = (< PL ,, Cn > , policyIn (DL, Cn)) .
eq policyIn(emp, Cn) = empty .
eq policyIn(NsD, Cn) = empty .


ceq dec(< PL, D, B, CnSet, T > Ncfg) = < PL, D, B, CnSet, (T - 1) > dec(Ncfg)
if (T - 1) =/= 0 .

ceq dec(< PL, D', B, CnSet, T > Ncfg) = dec(deleteF(PL, Ncfg))
if (T - 1) == 0 .

eq dec( Ncfg) =  Ncfg [owise] .

eq deleteDATA(PL, ((A |-> < NsD, PL' >), S))  =
if PL == PL' then deleteDATA(PL, S) else
((A |-> < NsD, PL' >), deleteDATA(PL, S)) fi .
eq deleteDATA(PL, ((A |-> NsD), S)) =  ((A |-> NsD), deleteDATA(PL, S)) .
eq deleteDATA(PL, noSub) = noSub .



***eq deleteF(PL, (MSG ))  =  (MSG) .
***eq deleteF(PL, (CLASS ))  = (CLASS)  .
eq deleteF(PL,( < O : C | Att: S, Pr: P, Lcnt: N, Db: DB >  Ncfg))  =  < O : C | Att: S, Pr: P, Lcnt: N, Db: deleteDATA(PL, DB) > (deleteF(PL,  Ncfg)) .
eq deleteF(PL, Ncfg) = Ncfg [owise] . 
***eq deleteF(PL, < User  | Log: H >)  = < User  | Log: H >  .
***eq deleteF(PL, (POLICY )) = POLICY  .

eq match(< NsD, PL >, < NsD', PL' >) =
if PL == PL' then true else false
fi .
eq match( NsD, NsD' ) = true .
eq match(< NsD, PL >,  NsD') = true .
eq match( NsD, < NsD', PL' >) = true .

op getPurpose(_,_) : Oid Oid ->  Msg .
op purpose(_,_,_) : Oid Oid Data ->  Msg .

rl [timestamp] :

{ tick 
Ncfg  }
=> 
{ 
 dec(Ncfg)  } .


crl [delete] :
{  < O : C | Att: S, Pr: (L, (delete( A) ; SL) @ V), Lcnt: N, Db: DB  >  < PL , D, B, CnSet, T >
Ncfg  }
=> 
{ 
 deleteF(PL, (< O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N, Db: DB  >) Ncfg )  }
 if ((dom('user, L) == true )) and (eval(A, (S # L)) == PL) .

crl [no-delete] :
  < O : C | Att: S, Pr: (L, (delete( A) ; SL) @ V ), Lcnt: N, Db: DB  >  

=> 
 < O : C | Att: S, Pr: (L,  (SL @ V) ), Lcnt: N, Db: DB  >
if (dom('user, L) == false ) .


rl [get-purpose] :
< O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
getPurpose(O', O)
=>
< O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
purpose(O, O', eval('purpose, S)) .

*** multiple assignment
eq < O : C | Att: S, Pr: (L,(((A,,A',,AL)::=(E,,E',,EL)); SL) @ V), Lcnt: N, Db: DB  >
=  < O : C | Att: S, Pr: (L,((A ::= eval(E,(S # L))); 
             (A',, AL ::= evalList(E',,EL,(S # L))); SL) @ V), Lcnt: N, Db: DB > .

rl [contract] :
< O : C | Att: S, Pr: (L,((A ::= contract(D, A')) ; SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L,((A ::= (< D, eval(A', (S # L)) >)) ; SL) @ V), Lcnt: N, Db: DB > .





crl [store1-and-error-store] :
{ < O : C | Att: S, Pr: (L,((store(K, A')) ; SL) @ V), Lcnt: N, Db: DB >
Ncfg  }
=>
if comply((< PL ,, (< eval('purpose, S), O >) >)\ V, Ncfg) then
{ < O : C | Att: S, Pr: (L, (SL @ V)), Lcnt: N, Db: (insert(K, NsD, DB)) >
Ncfg  }
else
{ < O : C | Att: S, Pr: error, Lcnt: N, Db: DB >
Ncfg  }
fi
if < NsD, PL > := (eval(A', (S # L))) .

crl [store2] :
 < O : C | Att: S, Pr: (L,((store(K, A')) ; SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, (SL @ V)), Lcnt: N, Db: (insert(K, NsD, DB)) >
if NsD := (eval(A', (S # L))) .

crl [retrieve] :
< O : C | Att: S, Pr: (L,(( retrieve(K, A) { SL } else { SL' }) ; SL'') @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (insert(A, eval(K, DB) , L), ( SL ; SL'') @ V), Lcnt: N, Db: DB  >
if (dom(K, DB) == true) and (dom(A, L) == true) .

crl [no-retrieve] :
< O : C | Att: S, Pr: (L,(( retrieve(K, A) { SL } else { SL' }) ; SL'') @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, (SL' ; SL'') @ V), Lcnt: N, Db: DB  >
if (dom(K, DB) == false) or (dom(A, L) == false) .


crl [op] :
< O : C | Att: S, Pr: (L,((A ::= E ++ E') ; SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, ((A ::= eval(E, (S # L)) + eval(E', (S # L)) ) ; SL) @ V), Lcnt: N , Db: DB > 
if match(eval(E, (S # L)), eval(E', (S # L))) == true .

crl [op-error] :
< O : C | Att: S, Pr: (L,((A ::= E ++ E') ; SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: error, Lcnt: N , Db: DB > 
if match(eval(E, (S # L)), eval(E', (S # L))) == false .

*** assignment
rl [assign] :
< O : C | Att: S, Pr: (L,((A ::= E); SL) @ V), Lcnt: N, Db: DB >
=>
if dom(A,L) then
< O : C | Att: S, Pr: (insert(A,eval(E,(S # L)), L), (SL @ V)), Lcnt: N , Db: DB > 
else
< O : C | Att: insert(A,eval(E,(S # L)), S), Pr: (L, (SL @ V)), Lcnt: N, Db: DB > 
fi .

rl [policy-and-error-policy] :
  < O : C | Att: S, Pr: (L, ((A ::= policy(B, T)) ; SL) @ V), Lcnt: N, Db: DB >
  =>
  if (dom('user, L) )  then
  < O : C | Att: S, Pr: (L, ((A ::= policyId(N)) ; SL) @ V), Lcnt: (N + 1), Db: DB >
  < (policyId(N)) , eval('user, L), B,( < str('main),  ob('main) >, < eval('purpose, S), O > ), T >
  else
  < O : C | Att: S, Pr: (error), Lcnt: N, Db: DB >
  fi .

rl [close-scope] :
< O : C | Att: S, Pr: (L, (cScope(V') ; SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, ( SL @ (V \ V'))), Lcnt: N, Db: DB > .

crl [if-consent] :
{ < O : C | Att: S, Pr: (L, ((if-consent(A, A') {SL} else {SL'}) ; SL'') @ V), Lcnt: N, Db: DB >  
Ncfg  }
  =>  
{  < O : C | Att: S, Pr: (L, (SL ; cScope(< eval(A', (S # L)) ,, eval(A, (S # L)) >) ; SL'') @ union(V, (< eval(A', (S # L)) ,, eval(A, (S # L)) >))), Lcnt: N, Db: DB >
  Ncfg  }
 if comply((< eval(A', (S # L)) ,, eval(A, (S # L)) >) \ V, Ncfg) == true .

crl [no-consent] :
{ < O : C | Att: S, Pr: (L, ((if-consent(A, A') {SL} else {SL'}) ; SL'') @ V), Lcnt: N, Db: DB >  
Ncfg  }
  =>  
{  < O : C | Att: S, Pr: (L, (SL' ; SL'') @ V), Lcnt: N, Db: DB >
  Ncfg  }
 if comply((< eval(A', (S # L)) ,, eval(A, (S # L)) >) \ V, Ncfg) == false .


crl [if-comply] :
{ < O : C | Att: S, Pr: (L, ((if-comply(A, EL) {SL} else {SL'}) ; SL'') @ V), Lcnt: N, Db: DB > 
 Ncfg }
  =>
{  < O : C | Att: S, Pr: (L, (SL ; cScope(policyIn(evalList(EL, (S # L)), eval(A, (S # L)))) ; SL'') @ union(V, policyIn(evalList(EL, (S # L)), eval(A, (S # L))))), Lcnt: N, Db: DB >  Ncfg }
if comply(policyIn(evalList(EL, (S # L)), eval(A, (S # L))) \ V, Ncfg) == true .

crl [no-comply] :
{ < O : C | Att: S, Pr: (L, ((if-comply(A, EL) {SL} else {SL'}) ; SL'') @ V), Lcnt: N, Db: DB > 
 Ncfg }
  =>
{  < O : C | Att: S, Pr: (L, (SL' ; SL'') @ V), Lcnt: N, Db: DB >  Ncfg }
if comply(policyIn(evalList(EL, (S # L)), eval(A, (S # L))) \ V, Ncfg) == false .


crl [collect] :
{ < O : C | Att: S, Pr: (L, ((A ::= collect(D, A', A'')) ; SL) @ V) , Lcnt: N, Db: DB >  
Ncfg }
  =>
{  < O : C | Att: S, Pr: (L, ((A ::= < D, eval(A'', (S # L)) > ) ; SL) @ V), Lcnt: N, Db: DB >
Ncfg }
if (comply((< eval(A'', (S # L)) ,, eval(A', (S # L)) >) \ V, Ncfg) == true) and (dom('user, L) == true ) .

crl [error-collect] :
{ < O : C | Att: S, Pr: (L, ((A ::= collect(D, A', A'')) ; SL) @ V) , Lcnt: N, Db: DB >  
Ncfg }
  =>
{  < O : C | Att: S, Pr: error, Lcnt: N, Db: DB > 
Ncfg }
if (comply((< eval(A'', (S # L)) ,, eval(A', (S # L)) >) \ V, Ncfg) == false) or (dom('user, L) == false ) .


rl [log-in-And-error-log-in] :
 < O : C | Att: S, Pr: (L, ((A ::= logIn(D)) ; SL) @ V), Lcnt: N, Db: DB >  
  =>
  if (dom('user, L) == false )  then
   < O : C | Att: S, Pr: ((insert(A, D, (insert('user, D, L)))),  (SL @ V)), Lcnt: N, Db: DB > 
   else
   < O : C | Att: S, Pr: (error), Lcnt: N, Db: DB >
 fi  .

rl [log-out-And-error-log-out] :
 < O : C | Att: S, Pr: (L, ( (logOut) ; SL @ V)), Lcnt: N, Db: DB >  
  =>
  if (dom('user, L) == true )  then
   < O : C | Att: S, Pr: ( (remove('user, L)),  (SL @ V)), Lcnt: N, Db: DB > 
   else
   < O : C | Att: S, Pr: (error), Lcnt: N, Db: DB >
 fi  .

rl [user-opt] :
 < O : C | Att: S, Pr: (L, (( optIn( A, A')) ; SL) @ V), Lcnt: N, Db: DB > 
 =>
 < O : C | Att: S, Pr: (L, ((freeze( optIn( A, A'))) ; SL) @ V), Lcnt: N, Db: DB >
 optInMsg(A, A') from O to User .

rl [option-true] :
< User | Log: H  > optInMsg(A, A') from O to User
=>
< User | Log: H ++ optInMsg(true, A, A')  > optInMsg(true, A, A') from User to O .


rl [option-false] :
< User | Log: H  > optInMsg(A, A') from O to User
=>
< User | Log: H ++ optInMsg(false, A, A')  > optInMsg(false, A, A') from User to O .



crl [opt-in] :
 < O : C | Att: S, Pr: (L, (( freeze(optIn( A, A'))) ; SL) @ V), Lcnt: N, Db: DB >  < PL , D', B', CnSet, T > optInMsg(B, A, A') from User to O
 =>
< O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N, Db: DB >  < PL , D', B', (insert(eval(A, (S # L)), CnSet)), T >
if ((eval(A', (S # L)) == PL) and (B == true) and  (dom('user, L))) .

crl [no-opt-in] :
 < O : C | Att: S, Pr: (L, (( freeze(optIn( A, A'))) ; SL) @ V), Lcnt: N, Db: DB > optInMsg(B, A, A') from User to O
 =>
 < O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N, Db: DB > 
if ( (B == false) and  (dom('user, L))) .

crl [error-opt-in] :
 < O : C | Att: S, Pr: (L, (( optIn( A, A')) ; SL) @ V), Lcnt: N, Db: DB >  
 =>
 < O : C | Att: S, Pr: (error), Lcnt: N, Db: DB > 
if ( dom('user, L) == false) .

crl [opt-out] :
 < O : C | Att: S, Pr: (L, (( optOut(B, A, A')) ; SL) @ V), Lcnt: N, Db: DB >  < PL , D', B', CnSet, T > 
 =>
< O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N, Db: DB >  < PL , D', B', (delete(eval(A, (S # L)), CnSet)), T >
if ((eval(A', (S # L)) == PL) and (B == true) and  (dom('user, L))) .

crl [no-opt-out] :
 < O : C | Att: S, Pr: (L, (( optOut(B, A, A')) ; SL) @ V), Lcnt: N, Db: DB > 
 =>
 < O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N, Db: DB > 
if ( (B == false) and  (dom('user, L))) .
*** skip
rl [skip] :
  < O : C | Att: S, Pr: (L, (skip ; SL) @ V), Lcnt: N, Db: DB >
  =>
  < O : C | Att: S, Pr: (L, (SL @ V)), Lcnt: N, Db: DB > .


*** OBJECT CREATION
rl [new-object] :
< O : C | Att: S,Pr: (L, ((A ::= new C' (EL)); SL) @ V), Lcnt: N, Db: DB > 
< C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: F >
=> 
< O : C | Att: S, Pr: (L, ((A ::= newId(C', F)); SL) @ V), Lcnt: N, Db: DB >
< C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: (F + 1) >
< newId(C',F) : C' | Att: noSub, Pr: idle, Lcnt: 1, Db: noSub >
findAttr(newId(C',F), I, (insert('purpose, str(C'), insert('myContract, < str(C'), newId(C',F) >, S'))), 
    (AL ::= evalList(EL, (S # L)))) .

*** ATTRIBUTE inheritance with multiple inheritance
*** CMC assumes that all attributes names are (globally) different
op findAttr  : Oid InhList Subst StmList  -> Msg [ctor] . *** collect attributes
op foundAttr : Oid Subst  StmList         -> Msg [ctor] . *** resulting Subst
*** look in InhList, collect attributes in Subst, give result to Oid

eq findAttr(O, noInh, S, SL)  *** collection completed.
       = foundAttr(O, S, SL) .

eq findAttr(O,((C < EL >) ## I),S, SL) 
< C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F >
 = findAttr(O, I ## I',(L # S), SL ; (AL ::= EL)) 
   < C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F > .

eq foundAttr(O, S', SL) 
< O : C | Att: S, Pr: idle, Lcnt: N, Db: DB >
 = < O : C | Att: ('this |-> O, S'), Pr: (noSub, (SL @ empty)), Lcnt: N, Db: DB > .



*** M?
rl [get-data] :
< O : C | Att: S, Pr: (L, ((AL ::= M ?) ; SL) @ V),  Lcnt: F, Db: DB > 
 comp(O, DL, V') 
=>
< O : C | Att: S,  Pr: (L, ((AL ::= DL) ; SL) @ V) , Lcnt: F, Db: DB > .


*** METHOD CALLS ***


*** receive invocation message ***
rl [receive-call-req] :
< O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
invoc(O', F, Q, DL, V) from O' to O  
=>
< O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
 bindMtd(O, O', F, Q, DL, C < emp >, V) .


crl [self-call] : 
{ < O : C | Att: S, Pr: (L, (( AL ::= E . M(EL)); SL) @ V), Lcnt: N, Db: DB >
Ncfg }
=>
if comply(policyIn(evalList(EL, (S # L)), (< eval('purpose, S), O >)) \ V, Ncfg) then
{ < O : C | Att: S, Pr: (L, (freeze((AL ::= M ?) ; SL)) @ V), Lcnt: N, Db: DB  > bindMtd(O, O, N, M, evalList(EL, (S # L)), C < emp >, empty ) 
Ncfg }
else
{ < O : C | Att: S, Pr: error, Lcnt: N, Db: DB  > 
Ncfg }
fi
if (eval(E, (S # L)) == O) .

rl [self-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: (L, (freeze((AL ::= M ?) ; SL)) @ V) , Lcnt: N, Db: DB > 
=>
< O : C | Att: S, Pr: (P + cat(newN(N, O))), Lcnt: (N + 1), Db: DB >
n(newN(N, O), (L, ((AL ::= M ?) ; SL ) @ V))  .

***rl [receive-call-req] :
**** < O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
*** invoc(O, N, Q , DL, V) from O to O
***=> 
***< O : C | Att: S, Pr: P, Lcnt: N, Db: DB >
*** bindMtd(O, O, N, Q, DL, C < emp >)  .

*** Method binding with multiple inheritance
***ceq bindMtd(O, O',N,Q, DL,noInh) = 
***boundMtd(O,(('caller |-> O', 'user |-> null), return(emp)))
***if Q == 'run .

eq bindMtd(O, O', N, Q, DL,(C < EL >)## I', V) 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F >
   =  if (Q in MS) then boundMtd(O,get(Q,MS,O', N, DL, V)) 
                   else bindMtd(O,O',N,Q, DL, I ## I', V) fi 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F > .




rl [receive-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: idle, Lcnt: N, Db: DB >
=> < O : C | Att: S, Pr: P, Lcnt: N, Db: DB > .




*** REMOTE METHOD CALLS ***
***rl [local-async-qualified-req] :
***< O : C | Att: S, Pr: (L, (  Q @ C'(EL)); SL), Lcnt: N, Db: DB >
***=> 
***< O : C | Att: S, Pr: (L, SL), Lcnt: N + 1, Db: DB >
***invoc(O, N, Q @ C', evalList(EL, (S # L))) from O to O .


crl [call-1] : 
< O : C | Att: S, Pr: (L, (( AL ::= E . M(EL)); SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, (freeze((AL ::= E . M(EL)); SL)) @ V), Lcnt: N, Db: DB  >
getPurpose(O, eval(E, (S # L)))
 if (eval(E, (S # L)) =/= O) .

rl [call-2] : 
{ ( < O : C | Att: S, Pr: (L, (freeze((AL ::= E . M(EL)) ; SL)) @ V), Lcnt: N, Db: DB  > )
(purpose(O', O, D))
 Ncfg }
=>
if comply(policyIn(evalList(EL, (S # L)), (< D, O' >)) \ V, Ncfg) then
{ Ncfg  (< O : C | Att: S, Pr: (L,  ((AL ::= M ?) ; SL) @ V), Lcnt: N + 1, Db: DB  >)
invoc(O, N, M , evalList(EL, (S # L)), intersection(V,policyIn(evalList(EL, (S # L)), (< D, O' >))))  from O to eval(E, (S # L)) }
else
{ Ncfg ( < O : C | Att: S, Pr: error, Lcnt: N, Db: DB   >) }
fi .


crl [call-1] : 
< O : C | Att: S, Pr: (L, (( E . M(EL)); SL) @ V), Lcnt: N, Db: DB >
=>
< O : C | Att: S, Pr: (L, (freeze( E . M(EL)); SL) @ V), Lcnt: N, Db: DB  >
getPurpose(O, eval(E, (S # L)))
if (eval(E, (S # L)) =/= O) .

rl [call-2] : 
{ ( < O : C | Att: S, Pr: (L, ((freeze( E . M(EL))) ; SL) @ V), Lcnt: N, Db: DB  > )
(purpose(O', O, D))
 Ncfg }
=>
if comply(policyIn(evalList(EL, (S # L)), (< D, O' >)) \ V, Ncfg) then
{ Ncfg  (< O : C | Att: S, Pr: (L,  (SL @ V)), Lcnt: N + 1, Db: DB  >)
invoc(O, N, M , evalList(EL, (S # L)), intersection(V,policyIn(evalList(EL, (S # L)), (< D, O' >))))  from O to eval(E, (S # L)) }
else
{ Ncfg ( < O : C | Att: S, Pr: error, Lcnt: N, Db: DB   >) }
fi .


***rl [remote-async-reply] : 
****< O : C | Att: S, Pr: (L, (   Q(EL)); SL), Lcnt: N, Db: DB >
***=>
***< O : C | Att: S, Pr: (L,  SL), Lcnt: N + 1, Db: DB >
***invoc(O, N, Q , evalList(EL, (S # L))) from O to O .


*** emit reply message ***
rl [return-check-purpose] :
< O : C |  Att: S, Pr: (L, (return(EL); SL) @ V), Lcnt: N, Db: DB >
=>
< O : C |  Att: S, Pr: (L, (freeze (return(EL); SL)) @ V), Lcnt: N, Db: DB >
getPurpose(O, eval('caller, L)) .

rl [return-get-purpose] :
{  < O : C |  Att: S, Pr: (L, (freeze (return(EL); SL)) @ V), Lcnt: N, Db: DB >
purpose(O', O, D)
Ncfg }
=>
if comply(policyIn(evalList(EL, (S # L)), (< D, O' >)) \ V, Ncfg) then
{ < O : C |  Att: S, Pr: (L, (SL @ V)), Lcnt: N, Db: DB > 
comp(eval('caller, L), evalList(EL, (S # L)), V) Ncfg } else
{ < O : C |  Att: S, Pr: error, Lcnt: N, Db: DB > Ncfg } fi .

***crl [return] :
***< O : C |  Att: S, Pr: (L, (return(EL)); SL), Lcnt: N, Db: DB >
***=>
***< O : C |  Att: S, Pr: (L, SL), Lcnt: N, Db: DB > 
***comp(eval('caller, L), evalList(EL, (S # L)))
***if  eval('caller, L) == ob('main) .

***crl [return] :
***< O : C |  Att: S, Pr: (L, (return(EL)); SL), Lcnt: N, Db: DB >
***=>
***< O : C |  Att: S, Pr: (L, SL), Lcnt: N, Db: DB > 
***if  evalList(EL, (S # L)) == emp .







endm
